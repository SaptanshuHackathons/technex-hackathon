"""
Database service using Supabase for storing crawl, chat, and page metadata.
Supports hierarchical page structure for tree-view display.
Uses singleton pattern for connection pooling.
"""

import os
import uuid
from typing import Dict, Optional, Any, List
from supabase import create_client, Client
from datetime import datetime
from functools import lru_cache
from config import SUPABASE_URL, SUPABASE_KEY


@lru_cache(maxsize=1)
def _get_supabase_client() -> Client:
    """
    Get singleton Supabase client instance.
    Uses lru_cache to ensure only one client is created.
    """
    if not SUPABASE_URL or not SUPABASE_KEY:
        raise ValueError(
            "SUPABASE_URL and SUPABASE_KEY must be set in environment variables"
        )

    client = create_client(SUPABASE_URL, SUPABASE_KEY)
    print(f"Connected to Supabase at {SUPABASE_URL}")
    return client


class DatabaseService:
    def __init__(self):
        # Use singleton client for connection pooling
        self.supabase: Client = _get_supabase_client()
        # Alias for compatibility
        self.widget_supabase = self.supabase
        print(f"DatabaseService initialized with Supabase")

    def create_crawl(self, url: str, crawl_id: Optional[str] = None) -> str:
        """
        Create a new crawl session.

        Args:
            url: The URL being crawled
            crawl_id: Optional crawl ID (if not provided, will be generated by DB)

        Returns:
            The crawl_id
        """
        data = {"url": url, "page_count": 0}
        if crawl_id:
            data["id"] = crawl_id

        result = self.supabase.table("crawls").insert(data).execute()
        return result.data[0]["id"]

    def update_crawl_page_count(self, crawl_id: str, count: int):
        """Update the page count for a crawl."""
        self.supabase.table("crawls").update({"page_count": count}).eq(
            "id", crawl_id
        ).execute()

    def get_crawl(self, crawl_id: str) -> Optional[Dict[str, Any]]:
        """Get crawl metadata by crawl_id."""
        result = self.supabase.table("crawls").select("*").eq("id", crawl_id).execute()
        return result.data[0] if result.data else None

    def find_crawl_by_url(self, url: str) -> Optional[Dict[str, Any]]:
        """
        Find an existing crawl by URL.
        Returns the most recent crawl for the given URL.

        Args:
            url: The URL to search for

        Returns:
            The crawl metadata if found, None otherwise
        """
        result = (
            self.supabase.table("crawls")
            .select("*")
            .eq("url", url)
            .order("created_at", desc=True)
            .limit(1)
            .execute()
        )
        return result.data[0] if result.data else None

    def get_crawl_pages(self, crawl_id: str) -> List[Dict[str, Any]]:
        """
        Get all pages for a crawl.

        Args:
            crawl_id: The crawl ID

        Returns:
            List of page records
        """
        result = (
            self.supabase.table("pages")
            .select("*")
            .eq("crawl_id", crawl_id)
            .order("created_at")
            .execute()
        )
        return result.data if result.data else []

    def create_chat(self, crawl_id: str, chat_id: Optional[str] = None) -> str:
        """
        Create a new chat session linked to a crawl.

        Args:
            crawl_id: The crawl ID this chat is associated with
            chat_id: Optional chat ID (if not provided, will be generated by DB)

        Returns:
            The chat_id
        """
        data = {"crawl_id": crawl_id}
        if chat_id:
            data["id"] = chat_id

        result = self.supabase.table("chats").insert(data).execute()
        return result.data[0]["id"]

    def get_chat(self, chat_id: str) -> Optional[Dict[str, Any]]:
        """Get chat metadata by chat_id."""
        result = self.supabase.table("chats").select("*").eq("id", chat_id).execute()
        return result.data[0] if result.data else None

    def get_crawl_id_from_chat_id(self, chat_id: str) -> Optional[str]:
        """Get the crawl_id associated with a chat_id."""
        chat = self.get_chat(chat_id)
        if chat:
            return chat.get("crawl_id")
        return None

    def find_chat_by_crawl_id(self, crawl_id: str) -> Optional[Dict[str, Any]]:
        """
        Find an existing chat for a crawl.
        Returns the most recent chat for the given crawl_id.

        Args:
            crawl_id: The crawl ID to search for

        Returns:
            The chat metadata if found, None otherwise
        """
        result = (
            self.supabase.table("chats")
            .select("*")
            .eq("crawl_id", crawl_id)
            .order("created_at", desc=True)
            .limit(1)
            .execute()
        )
        return result.data[0] if result.data else None

    def add_message(
        self,
        chat_id: str,
        role: str,
        content: str,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> str:
        """
        Add a message to a chat.

        Args:
            chat_id: The chat ID
            role: 'user' or 'assistant'
            content: Message content
            metadata: Optional metadata (e.g., sources, model info)

        Returns:
            The message_id
        """
        message_id = str(uuid.uuid4())

        # Extract sources from metadata if present
        sources = []
        if metadata and "sources" in metadata:
            sources = metadata.pop("sources")

        data = {
            "id": message_id,
            "chat_id": chat_id,
            "role": role,
            "content": content,
            "sources": sources,
        }

        self.supabase.table("messages").insert(data).execute()
        return message_id

    def get_messages(
        self, chat_id: str, limit: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Get messages for a chat, ordered by creation time.

        Args:
            chat_id: The chat ID
            limit: Optional limit on number of messages to return (most recent)

        Returns:
            List of messages
        """
        query = (
            self.supabase.table("messages")
            .select("*")
            .eq("chat_id", chat_id)
            .order("created_at", desc=False)
        )

        if limit:
            query = query.limit(limit)

        response = query.execute()
        return response.data

    def store_page(
        self,
        crawl_id: str,
        url: str,
        title: str = "",
        parent_url: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> str:
        """
        Store a page with hierarchical relationship.

        Args:
            crawl_id: The crawl session ID
            url: Page URL
            title: Page title
            parent_url: URL of the parent page (if any)
            metadata: Additional metadata

        Returns:
            The page_id
        """
        # Find parent_id if parent_url is provided
        parent_id = None
        if parent_url:
            parent_result = (
                self.supabase.table("pages")
                .select("id")
                .eq("crawl_id", crawl_id)
                .eq("url", parent_url)
                .execute()
            )

            if parent_result.data:
                parent_id = parent_result.data[0]["id"]

        data = {
            "crawl_id": crawl_id,
            "url": url,
            "title": title or url,
            "parent_id": parent_id,
            "metadata": metadata or {},
        }

        # Use upsert to avoid duplicates
        result = (
            self.supabase.table("pages")
            .upsert(data, on_conflict="crawl_id,url")
            .execute()
        )

        return result.data[0]["id"]

    def get_crawl_tree(self, crawl_id: str) -> List[Dict[str, Any]]:
        """
        Get all pages for a crawl as a flat list.

        Returns a list of all pages, each with an empty children array for frontend compatibility.
        """
        # Fetch all pages for this crawl
        result = (
            self.supabase.table("pages")
            .select("id, url, title, parent_id, metadata")
            .eq("crawl_id", crawl_id)
            .order("created_at")
            .execute()
        )

        if not result.data:
            return []

        # Return all pages as root-level items with empty children arrays
        return [{**page, "children": []} for page in result.data]

    def list_crawls(self) -> List[Dict[str, Any]]:
        """List all crawls."""
        result = (
            self.supabase.table("crawls")
            .select("*")
            .order("created_at", desc=True)
            .execute()
        )
        return result.data

    def list_chats(self) -> List[Dict[str, Any]]:
        """List all chats."""
        result = (
            self.supabase.table("chats")
            .select("*")
            .order("created_at", desc=True)
            .execute()
        )
        return result.data

    def update_chat_summary(self, chat_id: str, summary: str):
        """Update the summary for a chat."""
        self.supabase.table("chats").update({"summary": summary}).eq(
            "id", chat_id
        ).execute()

    def store_message(
        self,
        chat_id: str,
        role: str,
        content: str,
        sources: Optional[List[Dict[str, Any]]] = None,
    ) -> str:
        """
        Store a chat message.

        Args:
            chat_id: The chat session ID
            role: Message role ('user' or 'ai')
            content: Message content
            sources: Optional list of sources

        Returns:
            The message_id
        """
        data = {
            "chat_id": chat_id,
            "role": role,
            "content": content,
            "sources": sources or [],
        }

        result = self.supabase.table("messages").insert(data).execute()
        return result.data[0]["id"]

    def get_chat_messages(self, chat_id: str) -> List[Dict[str, Any]]:
        """Get all messages for a chat session."""
        result = (
            self.supabase.table("messages")
            .select("*")
            .eq("chat_id", chat_id)
            .order("created_at")
            .execute()
        )
        return result.data

    def delete_chat(self, chat_id: str) -> bool:
        """
        Delete a chat and all its messages.
        The database cascade will handle deleting messages automatically.

        Args:
            chat_id: The chat session ID to delete

        Returns:
            True if deletion was successful
        """
        try:
            # Delete the chat (messages will be deleted by CASCADE)
            self.supabase.table("chats").delete().eq("id", chat_id).execute()
            return True
        except Exception as e:
            print(f"Error deleting chat {chat_id}: {str(e)}")
            return False
