"""
Database service using Supabase for storing crawl, chat, and page metadata.
Supports hierarchical page structure for tree-view display.
"""

import os
from typing import Dict, Optional, Any, List
from supabase import create_client, Client
from datetime import datetime


class DatabaseService:
    def __init__(self):
        supabase_url = os.getenv("SUPABASE_URL")
        supabase_key = os.getenv("SUPABASE_KEY")

        if not supabase_url or not supabase_key:
            raise ValueError(
                "SUPABASE_URL and SUPABASE_KEY must be set in environment variables"
            )

        self.supabase: Client = create_client(supabase_url, supabase_key)
        print(f"Connected to Supabase at {supabase_url}")

    def create_crawl(self, url: str, crawl_id: Optional[str] = None) -> str:
        """
        Create a new crawl session.

        Args:
            url: The URL being crawled
            crawl_id: Optional crawl ID (if not provided, will be generated by DB)

        Returns:
            The crawl_id
        """
        data = {"url": url}
        if crawl_id:
            data["id"] = crawl_id

        result = self.supabase.table("crawls").insert(data).execute()
        return result.data[0]["id"]

    def update_crawl_page_count(self, crawl_id: str, count: int):
        """Update the page count for a crawl."""
        self.supabase.table("crawls").update({"page_count": count}).eq(
            "id", crawl_id
        ).execute()

    def get_crawl(self, crawl_id: str) -> Optional[Dict[str, Any]]:
        """Get crawl metadata by crawl_id."""
        result = self.supabase.table("crawls").select("*").eq("id", crawl_id).execute()
        return result.data[0] if result.data else None

    def create_chat(self, crawl_id: str, chat_id: Optional[str] = None) -> str:
        """
        Create a new chat session linked to a crawl.

        Args:
            crawl_id: The crawl ID this chat is associated with
            chat_id: Optional chat ID (if not provided, will be generated by DB)

        Returns:
            The chat_id
        """
        data = {"crawl_id": crawl_id}
        if chat_id:
            data["id"] = chat_id

        result = self.supabase.table("chats").insert(data).execute()
        return result.data[0]["id"]

    def get_chat(self, chat_id: str) -> Optional[Dict[str, Any]]:
        """Get chat metadata by chat_id."""
        result = self.supabase.table("chats").select("*").eq("id", chat_id).execute()
        return result.data[0] if result.data else None

    def get_crawl_id_from_chat_id(self, chat_id: str) -> Optional[str]:
        """Get the crawl_id associated with a chat_id."""
        chat = self.get_chat(chat_id)
        if chat:
            return chat.get("crawl_id")
        return None

    def store_page(
        self,
        crawl_id: str,
        url: str,
        title: str = "",
        parent_url: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> str:
        """
        Store a page with hierarchical relationship.

        Args:
            crawl_id: The crawl session ID
            url: Page URL
            title: Page title
            parent_url: URL of the parent page (if any)
            metadata: Additional metadata

        Returns:
            The page_id
        """
        # Find parent_id if parent_url is provided
        parent_id = None
        if parent_url:
            parent_result = (
                self.supabase.table("pages")
                .select("id")
                .eq("crawl_id", crawl_id)
                .eq("url", parent_url)
                .execute()
            )

            if parent_result.data:
                parent_id = parent_result.data[0]["id"]

        data = {
            "crawl_id": crawl_id,
            "url": url,
            "title": title or url,
            "parent_id": parent_id,
            "metadata": metadata or {},
        }

        # Use upsert to avoid duplicates
        result = (
            self.supabase.table("pages")
            .upsert(data, on_conflict="crawl_id,url")
            .execute()
        )

        return result.data[0]["id"]

    def get_crawl_tree(self, crawl_id: str) -> List[Dict[str, Any]]:
        """
        Get all pages for a crawl in a hierarchical structure.

        Returns a list of root pages, each with nested children.
        """
        # Fetch all pages for this crawl
        result = (
            self.supabase.table("pages")
            .select("id, url, title, parent_id, metadata")
            .eq("crawl_id", crawl_id)
            .order("created_at")
            .execute()
        )

        if not result.data:
            return []

        # Build a map of pages by ID
        pages_by_id = {page["id"]: {**page, "children": []} for page in result.data}

        # Build the tree structure
        root_pages = []
        for page in result.data:
            if page["parent_id"] is None:
                root_pages.append(pages_by_id[page["id"]])
            elif page["parent_id"] in pages_by_id:
                pages_by_id[page["parent_id"]]["children"].append(
                    pages_by_id[page["id"]]
                )

        return root_pages

    def list_crawls(self) -> List[Dict[str, Any]]:
        """List all crawls."""
        result = (
            self.supabase.table("crawls")
            .select("*")
            .order("created_at", desc=True)
            .execute()
        )
        return result.data

    def list_chats(self) -> List[Dict[str, Any]]:
        """List all chats."""
        result = (
            self.supabase.table("chats")
            .select("*")
            .order("created_at", desc=True)
            .execute()
        )
        return result.data

    def update_chat_summary(self, chat_id: str, summary: str):
        """Update the summary for a chat."""
        self.supabase.table("chats").update({"summary": summary}).eq(
            "id", chat_id
        ).execute()

    def store_message(
        self,
        chat_id: str,
        role: str,
        content: str,
        sources: Optional[List[Dict[str, Any]]] = None,
    ) -> str:
        """
        Store a chat message.

        Args:
            chat_id: The chat session ID
            role: Message role ('user' or 'ai')
            content: Message content
            sources: Optional list of sources

        Returns:
            The message_id
        """
        data = {
            "chat_id": chat_id,
            "role": role,
            "content": content,
            "sources": sources or [],
        }

        result = self.supabase.table("messages").insert(data).execute()
        return result.data[0]["id"]

    def get_chat_messages(self, chat_id: str) -> List[Dict[str, Any]]:
        """Get all messages for a chat session."""
        result = (
            self.supabase.table("messages")
            .select("*")
            .eq("chat_id", chat_id)
            .order("created_at")
            .execute()
        )
        return result.data
